# 作用域 (Scopes)

## 概述

作用域是指源代码中可以使用特定名称引用命名实体的区域。以下各节详细介绍了作用域规则和行为，这些规则和行为取决于实体的类型及其声明位置。名称如何解析为实体的过程在名称解析章节中有详细描述。有关用于运行析构函数的"析构作用域"的更多信息，可以在析构函数章节中找到。

## 项目作用域

### 模块中的项目作用域

直接在模块中声明的项目名称的作用域从模块的开始延伸到模块的结束。这些项目也是模块的成员，可以通过从其模块开始的路径来引用。

### 语句中的项目作用域

作为语句声明的项目名称的作用域从项目语句所在的块的开始延伸到块的结束。

### 重复项目名称

在同一模块或块中的同一命名空间内引入与另一个项目重复名称的项目是错误的。

### 遮蔽预导入项

模块中的项目可以遮蔽预导入中的项目。

## 关联项作用域

### 关联项作用域规则

关联项没有作用域，只能通过从它们关联的类型或特征开始的路径来引用。方法也可以通过调用表达式来引用。

### 重复关联项名称

与模块或块中的项目类似，在特征或实现中引入与特征或impl中同一命名空间中的另一个项目重复的项目是错误的。

## 模式绑定作用域

局部变量模式绑定的作用域取决于其使用位置：

- `let` 语句绑定的作用域从 `let` 语句之后开始，直到声明它的块的结束。
- 函数参数绑定的作用域在函数体内。
- `if let` 和 `while let` 绑定在后续条件以及结果块中有效。
- `match` 分支绑定的作用域在 match 守卫和 match 分支表达式中。

局部变量作用域不延伸到项目声明中。

### 模式绑定遮蔽

模式绑定允许遮蔽作用域中的任何名称，但以下情况是错误的：

- 常量项
- 结构体和枚举的构造函数

以下示例说明了局部绑定如何遮蔽项目声明：

```rust
fn shadow_example() {
    // 由于作用域中还没有局部变量，这解析为函数。
    foo(); // 打印 `function`
    let foo = || println!("closure");
    fn foo() { println!("function"); }
    // 这解析为局部闭包，因为它遮蔽了项目。
    foo(); // 打印 `closure`
}
```

## 预导入作用域

### 预导入概述

预导入将实体引入每个模块的作用域。这些实体不是模块的成员，但在名称解析过程中会被隐式查询。

### 预导入层次

预导入是分层的，如果它们包含相同名称的实体，一个会遮蔽另一个。预导入可能遮蔽其他预导入的顺序如下，较早的条目可能遮蔽较晚的条目：

1. 标准库预导入
2. 语言预导入

## Self 作用域

### Self 概述

虽然 `Self` 是具有特殊含义的关键字，但它在名称解析中的交互方式与普通名称类似。

### Self 类型作用域

在结构体、枚举、联合体、特征或实现定义中的隐式 `Self` 类型被视为类似于泛型参数，其作用域与泛型类型参数相同。

### Self 构造函数作用域

在实现的值命名空间中的隐式 `Self` 构造函数在实现体（实现的关联项）内处于作用域中。

```rust
// 结构体定义中的 Self 类型。
struct Recursive {
    f1: Option<Box<Self>>
}

// 实现中的 Self 值构造函数。
struct ImplExample();
impl ImplExample {
    fn example() -> Self { // Self 类型
        Self() // Self 值构造函数
    }
}